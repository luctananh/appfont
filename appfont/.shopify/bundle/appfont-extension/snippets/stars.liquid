{% assign design_settings = shop.metafields.setting.style %}
{% if design_settings %}
  {% assign font_settings = design_settings | parse_json %}
  {% assign font_value = font_settings.value %}

  <script>
    window.fontSettings = {{ font_value | json }};
    console.log("Font settings from liquid:", window.fontSettings);
  </script>
{% else %}
  <p>No font settings found.</p>
{% endif %}

<script src="https://appfont--development.gadget.app/api/client/web.min.js" defer="defer"></script>

<script>
    document.addEventListener("DOMContentLoaded", function () {

        // Hàm chèn CSS cho font từ URL blob
        function injectFontCSSFromBlob(blobURL, fontName, fontType, selectors) {
            const styleElement = document.createElement("style");
            styleElement.type = "text/css";

           let cssContent = `
              @font-face {
                font-family: "${fontName}";
                src: url('${blobURL}') format('${fontType}');
              }
            `;
             if(selectors){
                    styleElement.appendChild(document.createTextNode(cssContent + `
                           ${selectors} {
                                font-family: "${fontName}" !important;
                             }
                    `));
               }else {
                     console.warn("No elements selected. Font will not be applied.")
                }


            document.head.appendChild(styleElement);
            console.log("CSS injected for font:", fontName, "with format:", fontType, "and selectors:", selectors); // Log
        }
        // Hàm chèn CSS cho font từ đường dẫn URL thông thường
        function injectFontCSS(fontName, fontLink, selectors) {
            const styleElement = document.createElement("style");
            styleElement.type = "text/css";

            let cssContent = `
                @import url("${fontLink}");
                `;
            if(selectors){
                styleElement.appendChild(document.createTextNode(cssContent + `
                           ${selectors} {
                                font-family: "${fontName}" !important;
                             }
                    `));
               }else {
                     console.warn("No elements selected. Font will not be applied.")
                }

            document.head.appendChild(styleElement);
             console.log("CSS injected for font:", fontName, "with link:", fontLink, "and selectors:", selectors); // Log
        }

      // Hàm xác định type của font
        function getFontType(base64) {
            if (base64.startsWith('d09GR')) {
                return 'woff'; // WOFF
            } else if (base64.startsWith('AAEAAAA')) {
                return 'ttf'; // TTF
            } else if (base64.startsWith('OTTO')) {
                  return 'otf';  // OTF
            }
            return null;
        }
          // Hàm chuyển đổi base64 thành blob
        function base64toBlob(base64, type) {
          try {
              const bytes = atob(base64);
              const byteNumbers = new Array(bytes.length);
              for (let i = 0; i < bytes.length; i++) {
                   byteNumbers[i] = bytes.charCodeAt(i);
              }
              const byteArray = new Uint8Array(byteNumbers);
              return new Blob([byteArray], { type: type });
          } catch (error) {
              console.error("Error converting base64 to blob:", error);
              return null; // Return null to signal failure
          }
       }

        // Kiểm tra nếu `fontSettings` tồn tại và có link
        if (window.fontSettings && window.fontSettings.link) {
             const fontName = window.fontSettings.name || 'CustomFont';
             const fontLink = window.fontSettings.link;
             const selectedElements =  window.fontSettings.selectedElements;
           let selectors;
            if(selectedElements) {
              selectors =  selectedElements.split(',').join(', ');
            }

            // Kiểm tra nếu link có dạng base64
             if (fontLink.startsWith("d09GR") || fontLink.startsWith("AAEAAAA") || fontLink.startsWith("OTTO")) {
                const fontType = getFontType(fontLink);
                if(fontType) {
                   try{
                        const blob = base64toBlob(fontLink, `font/${fontType}`);
                         if (blob) {
                            const blobURL = URL.createObjectURL(blob);
                           injectFontCSSFromBlob(blobURL, fontName,fontType, selectors);
                         } else {
                             console.error("Blob creation failed for:", fontName);
                         }

                   } catch (error) {
                     console.error("Error processing base64 font:", error);
                    }
               } else {
                     console.error("Unsupported base64 font format");
               }
           }
            else if (fontLink && fontLink.startsWith('blob:')) {
                  // If blob URL, assume correct type is stored.
                 // We will use the last part of the font name as a fall back for file type
                let fileType = fontName.split('.').pop().toLowerCase() ;
                  if(fileType === 'otf' || fileType === 'ttf' || fileType === 'woff'){
                      injectFontCSSFromBlob(fontLink, fontName, fileType , selectors);
                   } else {
                      console.error("Error: cannot identify the type of font");
                    }
           }
            else if (fontLink) {
               injectFontCSS(fontName, fontLink, selectors);
             } else {
                console.error("Font link is missing or invalid.");
             }
           }else {
              console.error("Font settings not found or invalid.");
         }
    });
</script>